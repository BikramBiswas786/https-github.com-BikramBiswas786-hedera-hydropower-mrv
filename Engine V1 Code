const {
  Client,
  TopicMessageSubmitTransaction,
  PrivateKey,
  AccountId,
  TopicId,
  Hbar
} = require('@hashgraph/sdk');
require('dotenv').config();

const OPERATOR_ID = process.env.HEDERA_OPERATOR_ID;
const OPERATOR_KEY_STR = process.env.HEDERA_OPERATOR_KEY;
const AUDIT_TOPIC_ID = process.env.AUDIT_TOPIC_ID;
const EF_GRID = parseFloat(process.env.EF_GRID || "0.8");

if (!OPERATOR_ID || !OPERATOR_KEY_STR || !AUDIT_TOPIC_ID) {
  throw new Error("Missing HEDERA_OPERATOR_ID / HEDERA_OPERATOR_KEY / AUDIT_TOPIC_ID in .env");
}

const operatorKey = PrivateKey.fromString(OPERATOR_KEY_STR);
const client = Client.forTestnet();
client.setOperator(AccountId.fromString(OPERATOR_ID), operatorKey);
client.setDefaultMaxTransactionFee(new Hbar(2));

function validatePhysicsConstraints(reading) {
  const density = 1000;
  const gravity = 9.81;
  const efficiency = reading.efficiency ?? 0.85;

  const expectedPowerW =
    density * gravity * reading.flowRate_m3_per_s * reading.headHeight_m * efficiency;
  const expectedPowerKw = expectedPowerW / 1000;
  const measuredPowerKw = reading.generatedKwh;

  const deviation = Math.abs(measuredPowerKw - expectedPowerKw) / expectedPowerKw;

  const isValid = deviation <= 0.15;
  return {
    isValid,
    deviation,
    expectedPowerKw,
    measuredPowerKw,
    reason: isValid
      ? null
      : `Physics deviation ${(deviation * 100).toFixed(1)}% (>15%)`
  };
}

function validateTemporalConsistency(current, previous) {
  if (!previous) {
    return { isValid: true, reason: null };
  }

  if (current.generatedKwh < previous.generatedKwh) {
    return {
      isValid: false,
      reason: "Generation decreased between readings"
    };
  }

  const tCur = new Date(current.timestamp);
  const tPrev = new Date(previous.timestamp);
  if (tCur <= tPrev) {
    return {
      isValid: false,
      reason: "Timestamp not strictly increasing"
    };
  }

  const hoursDiff = (tCur - tPrev) / 1000 / 3600;
  const genDiff = current.generatedKwh - previous.generatedKwh;
  const expectedMax = 100 * hoursDiff;

  if (genDiff > expectedMax) {
    return {
      isValid: false,
      reason: `Generation increase too large: ${genDiff.toFixed(2)} kWh in ${hoursDiff.toFixed(2)} h`
    };
  }

  return { isValid: true, reason: null };
}

function validateEnvironmentalBounds(reading, siteConfig = {}) {
  const bounds = {
    pH: { min: 6.5, max: 8.5 },
    turbidity_ntu: { min: 0, max: 100 },
    temperature_celsius: { min: 0, max: 40 },
    flowRate_m3_per_s: siteConfig.flowRateBounds || { min: 0.1, max: 100 },
    headHeight_m: siteConfig.headBounds || { min: 10, max: 500 }
  };

  const violations = [];

  for (const [key, range] of Object.entries(bounds)) {
    const val = reading[key];
    if (val == null) continue;
    if (val < range.min || val > range.max) {
      violations.push(`${key}=${val} (expected ${range.min}-${range.max})`);
    }
  }

  return {
    isValid: violations.length === 0,
    violations
  };
}

function detectStatisticalAnomalies(current, history) {
  if (!history.length) {
    return { isValid: true, zScore: 0, reason: null };
  }

  const vals = history.map(r => r.generatedKwh);
  const mean = vals.reduce((a, b) => a + b, 0) / vals.length;
  const variance = vals.reduce((acc, v) => acc + Math.pow(v - mean, 2), 0) / vals.length;
  const stdDev = Math.sqrt(variance) || 1e-6;

  const z = Math.abs((current.generatedKwh - mean) / stdDev);

  if (z > 3) {
    return {
      isValid: false,
      zScore: z,
      reason: `Z-score ${z.toFixed(2)} > 3 (statistical anomaly)`
    };
  }
  return { isValid: true, zScore: z, reason: null };
}

function calculateTrustScore(results) {
  const weights = {
    physics: 0.30,
    temporal: 0.30,
    environmental: 0.20,
    statistical: 0.20
  };

  const scores = {
    physics: results.physics.isValid ? 1.0 : 0.0,
    temporal: results.temporal.isValid ? 1.0 : 0.0,
    environmental: results.environmental.isValid ? 1.0 : 0.0,
    statistical: results.statistical.isValid
      ? 1.0
      : Math.max(0, 1.0 - Math.min(results.statistical.zScore / 5, 1.0))
  };

  const trust =
    scores.physics * weights.physics +
    scores.temporal * weights.temporal +
    scores.environmental * weights.environmental +
    scores.statistical * weights.statistical;

  return trust;
}

function determineVerificationStatus(trustScore, config = {}) {
  const autoApproveThreshold = config.autoApproveThreshold ?? 0.90;
  const manualReviewThreshold = config.manualReviewThreshold ?? 0.50;

  if (trustScore >= autoApproveThreshold) {
    return {
      status: "APPROVED",
      method: "AI_AUTO_APPROVED"
    };
  } else if (trustScore >= manualReviewThreshold) {
    return {
      status: "FLAGGED",
      method: "MANUAL_REVIEW_REQUIRED"
    };
  } else {
    return {
      status: "REJECTED",
      method: "FAILED_VERIFICATION"
    };
  }
}

function calculateBaselineEmissions(egMWh, efGrid) {
  return egMWh * efGrid;
}

function calculateEmissionReductions(be, pe = 0, le = 0) {
  return be - pe - le;
}

class EngineV1 {
  constructor(config = {}) {
    this.config = {
      autoApproveThreshold: 0.90,
      manualReviewThreshold: 0.50,
      siteConfig: {},
      ...config
    };
    this.historyByDevice = new Map();
  }

  getHistory(deviceId) {
    if (!this.historyByDevice.has(deviceId)) {
      this.historyByDevice.set(deviceId, []);
    }
    return this.historyByDevice.get(deviceId);
  }

  async verifyAndPublish(telemetry) {
    const deviceId = telemetry.deviceId;
    const history = this.getHistory(deviceId);
    const previous = history[history.length - 1];

    const physics = validatePhysicsConstraints(telemetry.readings);
    const temporal = validateTemporalConsistency(telemetry, previous || telemetry);
    const environmental = validateEnvironmentalBounds(telemetry.readings, this.config.siteConfig);
    const statistical = detectStatisticalAnomalies(telemetry.readings, history);

    const validationResults = { physics, temporal, environmental, statistical };
    const trustScore = calculateTrustScore(validationResults);
    const decision = determineVerificationStatus(trustScore, this.config);

    const egMWh = telemetry.readings.generatedKwh / 1000;
    const be = calculateBaselineEmissions(egMWh, EF_GRID);
    const er = calculateEmissionReductions(be, 0, 0);

    const attestation = {
      deviceId,
      timestamp: telemetry.timestamp,
      verificationStatus: decision.status,
      trustScore: parseFloat(trustScore.toFixed(4)),
      checks: {
        physics,
        temporal,
        environmental,
        statistical
      },
      calculations: {
        EG_MWh: egMWh,
        EF_grid_tCO2_per_MWh: EF_GRID,
        BE_tCO2: be,
        PE_tCO2: 0,
        LE_tCO2: 0,
        ER_tCO2: er,
        RECs_issued: decision.status === "APPROVED" ? er : 0
      }
    };

    const topicId = TopicId.fromString(AUDIT_TOPIC_ID);
    const message = Buffer.from(JSON.stringify(attestation));

    const tx = await new TopicMessageSubmitTransaction()
      .setTopicId(topicId)
      .setMessage(message)
      .freezeWith(client)
      .sign(operatorKey);

    const resp = await tx.execute(client);
    const receipt = await resp.getReceipt(client);

    history.push(telemetry.readings);

    return {
      attestation,
      transactionId: resp.transactionId.toString(),
      status: receipt.status.toString()
    };
  }
}

async function main() {
  const args = process.argv.slice(2);
  const cmd = args[0];

  if (cmd === "submit") {
    const deviceId = args[1] || "TURBINE-1";
    const flow = parseFloat(args[2] || "2.5");
    const head = parseFloat(args[3] || "45");
    const gen = parseFloat(args[4] || "156");
    const ph = parseFloat(args[5] || "7.2");

    const engine = new EngineV1();

    const telemetry = {
      deviceId,
      timestamp: new Date().toISOString(),
      readings: {
        flowRate_m3_per_s: flow,
        headHeight_m: head,
        generatedKwh: gen,
        pH: ph,
        turbidity_ntu: 10,
        temperature_celsius: 18
      }
    };

    console.log("Submitting telemetry:", telemetry);

    const result = await engine.verifyAndPublish(telemetry);

    console.log("\n=== ENGINE V1 RESULT ===");
    console.log("Decision:", result.attestation.verificationStatus);
    console.log("Trust Score:", result.attestation.trustScore);
    console.log("ER (tCO2):", result.attestation.calculations.ER_tCO2);
    console.log("RECs issued (tCO2):", result.attestation.calculations.RECs_issued);
    console.log("Hedera TX:", result.transactionId);
    console.log("Status:", result.status);
    console.log("Audit Topic:", AUDIT_TOPIC_ID);
  } else {
    console.log("Usage:");
    console.log("node engine-v1.js submit <deviceId> <flow> <head> <generatedKwh> <pH>");
    console.log("Example:");
    console.log("node engine-v1.js submit TURBINE-1 2.5 45 156 7.2");
  }

  await client.close();
}

main().catch(console.error);
