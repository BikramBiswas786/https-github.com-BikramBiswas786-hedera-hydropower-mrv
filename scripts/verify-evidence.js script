// scripts/verify-evidence.js
// Verify attestation evidence from Hedera HCS

const {
  Client,
  AccountId,
  PrivateKey
} = require('@hashgraph/sdk');
const axios = require('axios');
require('dotenv').config();

const OPERATOR_ID = process.env.HEDERA_OPERATOR_ID;
const OPERATOR_KEY_STR = process.env.HEDERA_OPERATOR_KEY;
const AUDIT_TOPIC_ID = process.env.AUDIT_TOPIC_ID;

if (!OPERATOR_ID || !OPERATOR_KEY_STR || !AUDIT_TOPIC_ID) {
  throw new Error("Missing required env vars");
}

const operatorKey = PrivateKey.fromString(OPERATOR_KEY_STR);
const client = Client.forTestnet();
client.setOperator(AccountId.fromString(OPERATOR_ID), operatorKey);

async function fetchTopicMessages(topicId, limit = 100) {
  const mirrorNodeUrl = `https://testnet.mirrornode.hedera.com/api/v1/topics/${topicId}/messages?limit=${limit}&order=desc`;

  console.log(`\nFetching messages from topic ${topicId}...`);

  try {
    const response = await axios.get(mirrorNodeUrl);
    const messages = response.data.messages || [];

    console.log(`‚úì Found ${messages.length} messages`);
    return messages;
  } catch (error) {
    throw new Error(`Failed to fetch messages: ${error.message}`);
  }
}

function parseMessage(message) {
  try {
    const decoded = Buffer.from(message.message, 'base64').toString('utf8');
    return JSON.parse(decoded);
  } catch (error) {
    return null;
  }
}

function verifyAttestation(attestation) {
  const checks = [];

  // Check required fields
  if (!attestation.deviceId) {
    checks.push({ field: 'deviceId', status: 'MISSING' });
  } else {
    checks.push({ field: 'deviceId', status: 'OK', value: attestation.deviceId });
  }

  if (!attestation.timestamp) {
    checks.push({ field: 'timestamp', status: 'MISSING' });
  } else {
    checks.push({ field: 'timestamp', status: 'OK', value: attestation.timestamp });
  }

  if (!attestation.trustScore) {
    checks.push({ field: 'trustScore', status: 'MISSING' });
  } else {
    checks.push({ field: 'trustScore', status: 'OK', value: attestation.trustScore });
  }

  // Verify trust score range
  if (attestation.trustScore < 0 || attestation.trustScore > 1) {
    checks.push({ field: 'trustScore', status: 'INVALID', reason: 'Out of range [0, 1]' });
  }

  // Verify verification status
  const validStatuses = ['APPROVED', 'FLAGGED', 'REJECTED'];
  if (!validStatuses.includes(attestation.verificationStatus)) {
    checks.push({ field: 'verificationStatus', status: 'INVALID', value: attestation.verificationStatus });
  } else {
    checks.push({ field: 'verificationStatus', status: 'OK', value: attestation.verificationStatus });
  }

  // Verify checks structure
  const requiredChecks = ['physics', 'temporal', 'environmental', 'statistical', 'consistency'];
  for (const checkName of requiredChecks) {
    if (!attestation.checks || !attestation.checks[checkName]) {
      checks.push({ field: `checks.${checkName}`, status: 'MISSING' });
    } else {
      checks.push({ field: `checks.${checkName}`, status: 'OK', score: attestation.checks[checkName].score });
    }
  }

  // Verify calculations
  if (!attestation.calculations) {
    checks.push({ field: 'calculations', status: 'MISSING' });
  } else {
    const calc = attestation.calculations;
    if (typeof calc.ER_tCO2 === 'number') {
      checks.push({ field: 'calculations.ER_tCO2', status: 'OK', value: calc.ER_tCO2 });
    } else {
      checks.push({ field: 'calculations.ER_tCO2', status: 'MISSING' });
    }

    if (typeof calc.RECs_issued === 'number') {
      checks.push({ field: 'calculations.RECs_issued', status: 'OK', value: calc.RECs_issued });
    } else {
      checks.push({ field: 'calculations.RECs_issued', status: 'MISSING' });
    }
  }

  const failedChecks = checks.filter(c => c.status !== 'OK');
  const isValid = failedChecks.length === 0;

  return { isValid, checks, failedChecks };
}

async function main() {
  console.log("\nüîç HEDERA HYDROPOWER MRV - EVIDENCE VERIFICATION");
  console.log("=================================================");

  try {
    // Fetch messages from HCS
    const messages = await fetchTopicMessages(AUDIT_TOPIC_ID);

    if (messages.length === 0) {
      console.log("\n‚ö† No messages found in audit topic.");
      process.exit(0);
    }

    console.log("\nVerifying attestations...\n");

    let validCount = 0;
    let invalidCount = 0;

    for (let i = 0; i < Math.min(messages.length, 10); i++) {
      const msg = messages[i];
      const attestation = parseMessage(msg);

      if (!attestation) {
        console.log(`Message ${i + 1}: ‚úó Invalid JSON`);
        invalidCount++;
        continue;
      }

      const verification = verifyAttestation(attestation);

      if (verification.isValid) {
        console.log(`Message ${i + 1}: ‚úì VALID`);
        console.log(`  Device: ${attestation.deviceId}`);
        console.log(`  Status: ${attestation.verificationStatus}`);
        console.log(`  Trust: ${attestation.trustScore}`);
        console.log(`  RECs: ${attestation.calculations.RECs_issued} tCO2`);
        console.log(`  Sequence: ${msg.sequence_number}`);
        validCount++;
      } else {
        console.log(`Message ${i + 1}: ‚úó INVALID`);
        console.log(`  Failed checks: ${verification.failedChecks.length}`);
        for (const check of verification.failedChecks) {
          console.log(`    - ${check.field}: ${check.status} ${check.reason || ''}`);
        }
        invalidCount++;
      }
      console.log();
    }

    console.log("=== VERIFICATION SUMMARY ===");
    console.log(`Total Messages: ${Math.min(messages.length, 10)}`);
    console.log(`‚úì Valid: ${validCount}`);
    console.log(`‚úó Invalid: ${invalidCount}`);

    console.log("\n‚úì Evidence Verification Complete!");

  } catch (error) {
    console.error("\n‚ùå Error:", error.message);
    console.error(error.stack);
    process.exit(1);
  }

  await client.close();
}

main();
